# Software Development

## The Source Repository

*你们的代码存储在哪里？github or gitlab?*

**Most of Google’s code is stored in a single unified source-code repository, and is accessible to all software engineers at Google.** (Customer data is tightly secured, it's only source code that's accessible.) There are some notable exceptions to the use of this single widely accessible repository, particularly the two large open-source projects Chrome and Android, which use separate open-source repositories, and some high-value or security-critical pieces of code for which read access is locked down more tightly. But most Google projects share the same repository. As of January 2015, this 86 terabyte repository contained a billion files, including over 9 million source code files containing a total of 2 billion lines of source code, with a history of 35 million commits and a change rate of 40 thousand commits per work day. Write access to the repository is controlled: only the listed owners of each subtree of the repository can approve changes to that subtree. But generally any engineer can access any piece of code, can check it out and build it, can make local modifications, can test them, and can send changes for review by the code owners, and if an owner approves, can check in (commit) those changes. Culturally, engineers are encouraged to fix anything that they see is broken and know how to fix, regardless of project boundaries. This empowers engineers and leads to higher-quality infrastructure(基础架构) that better meets the needs of those using it.

*我们的开发习惯与google相同，所有开发均在head of develop branch上进行，每解决一个新的问题，需在head of develop branch上拉下一个新的分支，解决完毕后merge回develop branch. Head of develop branch就是我们release给系统软件的代码库。*

**Almost all development occurs at the “head” of the repository, not on branches.** This helps identify integration(集成) problems early and minimizes the amount of merging work needed. It also makes it much easier and faster to push out security fixes.

*为保证程序的正常运行（可编译、可运行），我们采用了两种措施，工程师自己进行的单元测试和功能测试、集成后的daily功能测试，daily test是自动执行的，每天自动拉下head of develop branch代码，编译运行，生成结果，工程师每天早上查看运行结果文件。*

*上述步骤仅能保证程序可正常运行，但无法判断算法的准确性，后面需要添加算法准确性测试的test case，需要考虑不同年龄、性别、人数、光线、场景、运动速度等情况。*

**Automated systems run tests frequently, often after every change to any file in the transitive dependencies(传递依赖) of the test, although this is not always feasible(可行的).** These systems automatically notify the author and reviewers of any change for which the tests failed, typically within a few minutes. Most teams make the current status of their build very conspicuous(显眼的) by installing prominent(突出的) displays or even sculptures(雕塑) with color-coded lights (green for building successfully and all tests passing, red for some tests failing, black for broken build). This helps to focus engineers’ attention on keeping the build green. Most larger teams also have a “build cop” who is responsible for ensuring that the tests continue to pass at head, by working with the authors of the offending(惹麻烦的) changes to quickly fix any problems or to roll back the offending change. (The build cop role is typically rotated among the team or among its more experienced members.) This focus on keeping the build green makes development at head practical, even for very large teams.

*这个没啥，每个gitlab工程需要设置权限，owner or developer or viewer，不能让别人瞎逼改，对吧。*

**Code ownership.** Each subtree of the repository can have a file listing the user ids of the “owners” of that subtree. Subdirectories also inherit owners from their parent directories, although that can be optionally suppressed(抑制). The owners of each subtree control write access to that subtree, as described in the code review section below. Each subtree is required to have at least two owners, although typically there are more, especially in geographically distributed teams. It is common for the whole team to be listed in the owners file. Changes to a subtree can be made by anyone at Google, not just the owners, but must be approved by an owner. This ensures that every change is reviewed by an engineer who understands the software being modified.

## The Build System

*编译工具，之前好像用Blaze编译过tensorflow，我们现在用MakeFile，没啥，其实是一样的，完成相同的功能。*

Google uses a distributed build system known as Blaze, which is responsible for compiling and linking software and for running tests. It provides standard commands for building and testing software that work across the whole repository. These standard commands and the highly optimized implementation mean that it is typically very simple and quick for any Google engineer to build and test any software in the repository. This consistency is a key enabler which helps to make it practical for engineers to make changes across project boundaries.

Programmers write “BUILD” files that Blaze uses to determine how to build their software. Build entities such as libraries, programs, and tests are declared using fairly high-level declarative build specifications that specify, for each entity, its name, its source files, and the libraries or other build entities that it depends on. These build specifications are comprised(构成) of declarations called “build rules” that each specify high-level concepts like “here is a C++ library with these source files which depends on these other libraries”, and it is up to the build system to map each build rule to a set of build steps, e.g. steps for compiling each source file and steps for linking, and for determining which compiler and compilation flags to use.

In some cases, notably Go programs, build files can be generated (and updated) automatically, since the dependency information in the BUILD files is (often) an abstraction of the dependency information in the source files. But they are nevertheless(仍然) checked in to the repository. This ensures that the build system can quickly determine dependencies by analyzing only the build files rather than the source files, and it avoids excessive coupling between the build system and compilers or analysis tools for the many different programming languages supported.

*就我们这点小工程，不需要大型的计算机集群，一台服务器跑跑就足够了。其实思想是一致的，一台服务器运行不过来，耗时太长，就上服务器集群嘛。CPU完成不了的训练，就上GPU嘛，一个GPU不行，那多装几个，没啥。*

The build system’s implementation uses Google’s distributed computing infrastructure. **The work of each build is typically distributed across hundreds or even thousands of machines.** This makes it possible to build extremely large programs quickly or to run thousands of tests in parallel.

**Individual build steps must be “hermetic(不受外界影响的)”: they depend only on their declared inputs.** Enforcing that all dependencies be correctly declared is a consequence of distributing the build: only the declared inputs are sent to the machine on which the build step is run. As a result the build system can be relied on to know the true dependencies. Even the compilers that the build system invokes are treated as inputs.

*每一个编译步骤都是确定性的，只要有相同的输入，得到的lib和可执行文件就是相同的。其实就是，编译过程要有一致性，不能相同的程序，得到不一样的编译结果，运行出来是不一样的。上述明确声明每个编译步骤的依赖关系，也是为了这个目的。*

**Individual build steps are deterministic(确定性的).** As a consequence, the build system can cache build results. Software engineers can sync their workspace back to an old change number and can rebuild and will get exactly the same binary. Furthermore, this cache can be safely shared between different users. (To make this work properly, we had to eliminate non-determinism in the tools invoked by the build, for example by scrubbing out(清除) timestamps in the generated output files.)

**The build system is reliable.** The build system tracks dependencies on changes to the build rules themselves, and knows to rebuild targets if the action to produce them changed, even if the inputs to that action didn’t, for example when only the compiler options changed. It also deals properly with interrupting the build part way, or modifying source files during the build: in such cases, you need only rerun the build command. There is never any need to run the equivalent of “make clean”.

**Build results are cached “in the cloud”.** This includes intermediate results. If another build request needs the same results, the build system will automatically reuse them rather than rebuilding, even if the request comes from a different user.

**Incremental(增量) rebuilds are fast.** The build system stays resident in memory so that for rebuilds it can incrementally analyze just the files that have changed since the last build.

*Code review或者代码提交之前，自动做一定的测试，用来测试代码的正确性，给code reviewer和开发人员一定的提示。这个其实是有必要的，最起码code review之前，运行一定的代码测试，是非常有必要的。因为我们的code review是缺失的，这一步我们当然也没有做。如果我们后面添加了code review的步骤，一定会要求开发人员，在review之前，拿出相关代码的测试结果。*

**Presubmit checks.** Google has tools for automatically running a suite of tests when initiating a code review and/or preparing to commit a change to the repository. Each subtree of the repository can contain a configuration file which determines which tests to run, and whether to run them at code review time, or immediately before submitting, or both. The tests can be either synchronous, i.e. run before sending the change for review and/or before committing the change to the repository (good for fast-running tests); or asynchronous(异步), with the results emailed to the review discussion thread. The review thread is the email thread on which the code review takes place; all the information in that thread is also displayed in the web-based code review tool.
