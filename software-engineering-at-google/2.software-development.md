# Software Development

## The Source Repository

*你们的代码存储在哪里？github or gitlab?*

**Most of Google’s code is stored in a single unified source-code repository, and is accessible to all software engineers at Google.** (Customer data is tightly secured, it's only source code that's accessible.) There are some notable exceptions to the use of this single widely accessible repository, particularly the two large open-source projects Chrome and Android, which use separate open-source repositories, and some high-value or security-critical pieces of code for which read access is locked down more tightly. But most Google projects share the same repository. As of January 2015, this 86 terabyte repository contained a billion files, including over 9 million source code files containing a total of 2 billion lines of source code, with a history of 35 million commits and a change rate of 40 thousand commits per work day. Write access to the repository is controlled: only the listed owners of each subtree of the repository can approve changes to that subtree. But generally any engineer can access any piece of code, can check it out and build it, can make local modifications, can test them, and can send changes for review by the code owners, and if an owner approves, can check in (commit) those changes. Culturally, engineers are encouraged to fix anything that they see is broken and know how to fix, regardless of project boundaries. This empowers engineers and leads to higher-quality infrastructure(基础架构) that better meets the needs of those using it.

*我们的开发习惯与google相同，所有开发均在head of develop branch上进行，每解决一个新的问题，需在head of develop branch上拉下一个新的分支，解决完毕后merge回develop branch. Head of develop branch就是我们release给系统软件的代码库。*

**Almost all development occurs at the “head” of the repository, not on branches.** This helps identify integration(集成) problems early and minimizes the amount of merging work needed. It also makes it much easier and faster to push out security fixes.

*为保证程序的正常运行（可编译、可运行），我们采用了两种措施，工程师自己进行的单元测试和功能测试、集成后的daily功能测试，daily test是自动执行的，每天自动拉下head of develop branch代码，编译运行，生成结果，工程师每天早上查看运行结果文件。*

*上述步骤仅能保证程序可正常运行，但无法判断算法的准确性，后面需要添加算法准确性测试的test case，需要考虑不同年龄、性别、人数、光线、场景、运动速度等情况。*

**Automated systems run tests frequently, often after every change to any file in the transitive dependencies(传递依赖) of the test, although this is not always feasible(可行的).** These systems automatically notify the author and reviewers of any change for which the tests failed, typically within a few minutes. Most teams make the current status of their build very conspicuous(显眼的) by installing prominent(突出的) displays or even sculptures(雕塑) with color-coded lights (green for building successfully and all tests passing, red for some tests failing, black for broken build). This helps to focus engineers’ attention on keeping the build green. Most larger teams also have a “build cop” who is responsible for ensuring that the tests continue to pass at head, by working with the authors of the offending(惹麻烦的) changes to quickly fix any problems or to roll back the offending change. (The build cop role is typically rotated among the team or among its more experienced members.) This focus on keeping the build green makes development at head practical, even for very large teams.

*这个没啥，每个gitlab工程需要设置权限，owner or developer or viewer，不能让别人瞎逼改，对吧。*

**Code ownership.** Each subtree of the repository can have a file listing the user ids of the “owners” of that subtree. Subdirectories also inherit owners from their parent directories, although that can be optionally suppressed(抑制). The owners of each subtree control write access to that subtree, as described in the code review section below. Each subtree is required to have at least two owners, although typically there are more, especially in geographically distributed teams. It is common for the whole team to be listed in the owners file. Changes to a subtree can be made by anyone at Google, not just the owners, but must be approved by an owner. This ensures that every change is reviewed by an engineer who understands the software being modified.

## The Build System

*编译工具，之前好像用Blaze编译过tensorflow，我们现在用MakeFile，没啥，其实是一样的，完成相同的功能。*

Google uses a distributed build system known as Blaze, which is responsible for compiling and linking software and for running tests. It provides standard commands for building and testing software that work across the whole repository. These standard commands and the highly optimized implementation mean that it is typically very simple and quick for any Google engineer to build and test any software in the repository. This consistency is a key enabler which helps to make it practical for engineers to make changes across project boundaries.

Programmers write “BUILD” files that Blaze uses to determine how to build their software. Build entities such as libraries, programs, and tests are declared using fairly high-level declarative build specifications that specify, for each entity, its name, its source files, and the libraries or other build entities that it depends on. These build specifications are comprised(构成) of declarations called “build rules” that each specify high-level concepts like “here is a C++ library with these source files which depends on these other libraries”, and it is up to the build system to map each build rule to a set of build steps, e.g. steps for compiling each source file and steps for linking, and for determining which compiler and compilation flags to use.

In some cases, notably Go programs, build files can be generated (and updated) automatically, since the dependency information in the BUILD files is (often) an abstraction of the dependency information in the source files. But they are nevertheless(仍然) checked in to the repository. This ensures that the build system can quickly determine dependencies by analyzing only the build files rather than the source files, and it avoids excessive coupling between the build system and compilers or analysis tools for the many different programming languages supported.

*就我们这点小工程，不需要大型的计算机集群，一台服务器跑跑就足够了。其实思想是一致的，一台服务器运行不过来，耗时太长，就上服务器集群嘛。CPU完成不了的训练，就上GPU嘛，一个GPU不行，那多装几个，没啥。*

The build system’s implementation uses Google’s distributed computing infrastructure. **The work of each build is typically distributed across hundreds or even thousands of machines.** This makes it possible to build extremely large programs quickly or to run thousands of tests in parallel.

**Individual build steps must be “hermetic(不受外界影响的)”: they depend only on their declared inputs.** Enforcing that all dependencies be correctly declared is a consequence of distributing the build: only the declared inputs are sent to the machine on which the build step is run. As a result the build system can be relied on to know the true dependencies. Even the compilers that the build system invokes are treated as inputs.

*每一个编译步骤都是确定性的，只要有相同的输入，得到的lib和可执行文件就是相同的。其实就是，编译过程要有一致性，不能相同的程序，得到不一样的编译结果，运行出来是不一样的。上述明确声明每个编译步骤的依赖关系，也是为了这个目的。*

**Individual build steps are deterministic(确定性的).** As a consequence, the build system can cache build results. Software engineers can sync their workspace back to an old change number and can rebuild and will get exactly the same binary. Furthermore, this cache can be safely shared between different users. (To make this work properly, we had to eliminate non-determinism in the tools invoked by the build, for example by scrubbing out(清除) timestamps in the generated output files.)

**The build system is reliable.** The build system tracks dependencies on changes to the build rules themselves, and knows to rebuild targets if the action to produce them changed, even if the inputs to that action didn’t, for example when only the compiler options changed. It also deals properly with interrupting the build part way, or modifying source files during the build: in such cases, you need only rerun the build command. There is never any need to run the equivalent of “make clean”.

**Build results are cached “in the cloud”.** This includes intermediate results. If another build request needs the same results, the build system will automatically reuse them rather than rebuilding, even if the request comes from a different user.

**Incremental(增量) rebuilds are fast.** The build system stays resident in memory so that for rebuilds it can incrementally analyze just the files that have changed since the last build.

*Code review或者代码提交之前，自动做一定的测试，用来测试代码的正确性，给code reviewer和开发人员一定的提示。这个其实是有必要的，最起码code review之前，运行一定的代码测试，是非常有必要的。因为我们的code review是缺失的，这一步我们当然也没有做。如果我们后面添加了code review的步骤，一定会要求开发人员，在review之前，拿出相关代码的测试结果。*

**Presubmit checks.** Google has tools for automatically running a suite of tests when initiating a code review and/or preparing to commit a change to the repository. Each subtree of the repository can contain a configuration file which determines which tests to run, and whether to run them at code review time, or immediately before submitting, or both. The tests can be either synchronous, i.e. run before sending the change for review and/or before committing the change to the repository (good for fast-running tests); or asynchronous(异步), with the results emailed to the review discussion thread. The review thread is the email thread on which the code review takes place; all the information in that thread is also displayed in the web-based code review tool.

## Code Review

*非常牛逼的code review工具，帮助reviewers更好的进行code review，发现问题并解决问题。没啥，就是个code review工具而已，相信开源的也可以满足我们的需求。*

**Google has built excellent web-based code review tools, integrated with email, that allow authors to request a review, and allows reviewers to view side-by-side diffs (with nice color coding) and comment on them.** When the author of a change initiates a code review, the reviewers are notified by e-mail, with a link to the web review tool’s page for that change. Email notifications are sent when reviewers submit their review comments. In addition, automated tools can send notifications, containing for example the results of automated tests or the findings of static analysis tools.

*每一个改动，必须有别的工程师进行code review，以保证不会出错。如果文件的修改者不是文件的owner，则必须由owner进行review或者批准当前修改，没啥，这是必须的，不能由着两个不熟悉的工程师瞎逼改。*

**All changes to the main source code repository MUST be reviewed by at least one other engineer.** In addition, if the author of a change is not one of the owners of the files being modified, then at least one of the owners must review and approve the change.

*当一个bug已经影响到上线了，非常着急，必须被快速修改，不然用户将远离我们而去，那可以运行临时上传，而不经过code review，那code review是不是可以躲过去了，白日做梦，后面还需要补上撒，要不然，劳资一直给你发消息，直到你做完了code review，腻害不腻害？*

In exceptional cases, an owner of a subtree can check in (commit) an urgent change to that subtree before it is reviewed, but a reviewer must still be named, and the change author and reviewer will get automatically nagged(唠叨) about it until the change has been reviewed and approved. In such cases, any modifications needed to address review comments must be done in a separate change, since the original change will have already been committed.

*google的工具可以自动推荐code reviewer，依据文件的修改者和拥有者、最近谁做reveiwer了，还有每个人待review的数目，不能把人累死，对吧。但是呢，每个修改者也可以自己选合适的review的人。我们在实际执行的时候，是两两之间相互做code review，不需要工具帮忙指定。*

Google has tools for automatically suggesting reviewer(s) for a given change, by looking at the ownership and authorship of the code being modified, the history of recent reviewers, and the number of pending(有待) code reviews for each potential reviewer. At least one of the owners of each subtree which a change affects must review and approve that change. But apart from that, the author is free to choose reviewer(s) as they see fit.

*由谁对自己修改的代码进行review，其实由修改者自己控制，如果觉着代码修改比较复杂，需要更多的人或更富有经验的人来做code review，那就自己找。如果代码修改相对简单，找个不那么牛逼的人即可，但是不能不做code review。*

One potential issue with code review is that if the reviewers are too slow to respond or are overly reluctant(厌恶) to approve changes, this could potentially slow down development. The fact that the code author chooses their reviewers helps avoid such problems, allowing engineers to avoid reviewers that might be overly possessive(占有的) about their code, or to send reviews for simple changes to less thorough reviewers and to send reviews for more complex changes to more experienced reviewers or to several reviewers.

*当发现一个bug之后，需要追踪到最开始引入这个bug的提交，让修改者和code reviewer都知道这个错误，找到引入这个错误的原因，打怪升级，避免以后再发生相同的问题。*

**Code review discussions for each project are automatically copied to a mailing list designated by the project maintainers.** Anyone is free to comment on any change, regardless of whether they were named as a reviewer of that change, both before and after the change is committed. If a bug is discovered, it’s common to track down the change that introduced it and to comment on the original code review thread to point out the mistake so that the original author and reviewers are aware of it.

It is also possible to send code reviews to several reviewers and then to commit the change as soon as one of them has approved (provided(倘若) either the author or the first responding reviewer is an owner, of course), before the other reviewers have commented, with any subsequent review comments being dealt with in follow-up changes. This can reduce the turnaround time for reviews.

*每个工程都有实验的部分，之前在riseauto的时候，是建立一个文件夹来保存实验性质的代码，这些代码是不用做code review的，但是推荐做。先在实验性的代码分支写代码，然后在转到主分支，做code review，这种方式是不推荐的，code review在开发过程中做更方便一些，也更容易发现问题。*

**In addition to the main section of the repository, there is an “experimental” section of the repository where the normal code review requirements are not enforced.** However, code running in production must be in the main section of the repository, and engineers are very strongly encouraged to develop code in the main section of the repository, rather than developing in experimental and then moving it to the main section, since code review is most effective when done as the code is developed rather than afterwards. In practice engineers often request code reviews even for code in experimental.

*这个很容易想到，每次修改不能太大，你一年写的代码，好做review吗？肯定不行啊！google的做法是值得学习的，即便是犯了错误，或者做了不好的事情，也没必要苦大仇深的，好像死了爹一样，开心的对待，找一个非常有乐趣的方式，人生苦短，及时行乐嘛。*

**Engineers are encouraged to keep each individual change small, with larger changes preferably broken into a series of smaller changes that a reviewer can easily review in one go.** This also makes it easier for the author to respond to major changes suggested during the review of each piece; very large changes are often too rigid(僵化) and resist reviewer-suggested changes. One way in which keeping changes small is encouraged is that the code review tools label each code review with a description of the size of the change, with changes of 30-99 lines added/deleted/removed being labelled “medium-size” and with changes of above 300 lines being labelled with increasingly disparaging(蔑视) labels, e.g. “large” (300-999), “freakin huge” (1000-1999), etc. (However, in a typically Googly way, this is kept fun by replacing these familiar descriptions with amusing alternatives on a few days each year, such as talk-like-a-pirate day.)

## Testing

*单元测试在google非常推荐和流行，没啥，我们写的每一段代码，也需要经过单元测试，但是，有意思的问题来了，啥叫单元测试？在code review之前，reviewer要求每一个新增的代码模块，都需要经过单元测试，并且给出测试结果。*

**Unit Testing is strongly encouraged and widely practiced at Google.** All code used in production is expected to have unit tests, and the code review tool will highlight if source files are added without corresponding tests. Code reviewers usually require that any change which adds new functionality should also add new tests to cover the new functionality. Mocking frameworks (which allow construction of lightweight unit tests even for code with dependencies on heavyweight libraries) are quite popular.

*集成测试和回归测试。*

Integration testing and regression testing are also widely practiced.

As discussed in "Presubmit Checks" above, testing can be automatically enforced as part of the code review and commit process.

Google also has automated tools for measuring test coverage. The results are also integrated as an optional layer in the source code browser.

*负载测试，主要是测试每个API的并发性，如果有10亿个人同时请求，会发生什么，延迟是多少，跟我们没关系，跟智美他们有关系，云端的嘛。*

**Load testing(负载测试) prior to deployment is also de rigueur at Google.** Teams are expected to produce a table or graph showing how key metrics, particularly latency and error rate, vary with the rate of incoming requests.

## Bug tracking

*每个发现的bug，都需要有个地方来追踪，测试人员可以新建bug，让研发人员来修改，我们用的是jira，梅姐都知道bug追踪，只有春爷不知道而已，哈哈。产品提的新需求，也是在jira上跟踪，只要有个地方方便记录，别忘了就行，不管啥工具。*

Google uses a bug tracking system called Buganizer for tracking issues: bugs, feature requests, customer issues, and processes (such as releases or clean-up efforts). Bugs are categorized into hierarchical components and each component can have a default assignee and default email list to CC. When sending a source change for review, engineers are prompted to associate the change with a particular issue number.

*这叫啥，过bug，只不过，我们公司的过bug跟玩儿一样，一群傻逼来过bug，过你麻痹过！过bug的时候，需要确定以下几件事，这个问题属于谁，大概是由什么原因导致的，什么时候可以解决。*

It is common (though not universal) for teams at Google to regularly scan through open issues in their component(s), prioritizing them and where appropriate assigning them to particular engineers. Some teams have a particular individual responsible for bug triage(分流), others do bug triage in their regular team meetings. Many teams at Google make use of labels on bugs to indicate whether bugs have been triaged, and which release(s) each bug is targeted to be fixed in.
