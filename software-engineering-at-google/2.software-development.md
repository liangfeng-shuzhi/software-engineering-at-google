# Software Development

## The Source Repository

*你们的代码存储在哪里？github or gitlab?*

**Most of Google’s code is stored in a single unified source-code repository, and is accessible to all software engineers at Google.** (Customer data is tightly secured, it's only source code that's accessible.) There are some notable exceptions to the use of this single widely accessible repository, particularly the two large open-source projects Chrome and Android, which use separate open-source repositories, and some high-value or security-critical pieces of code for which read access is locked down more tightly. But most Google projects share the same repository. As of January 2015, this 86 terabyte repository contained a billion files, including over 9 million source code files containing a total of 2 billion lines of source code, with a history of 35 million commits and a change rate of 40 thousand commits per work day. Write access to the repository is controlled: only the listed owners of each subtree of the repository can approve changes to that subtree. But generally any engineer can access any piece of code, can check it out and build it, can make local modifications, can test them, and can send changes for review by the code owners, and if an owner approves, can check in (commit) those changes. Culturally, engineers are encouraged to fix anything that they see is broken and know how to fix, regardless of project boundaries. This empowers engineers and leads to higher-quality infrastructure(基础架构) that better meets the needs of those using it.

*我们的开发习惯与google相同，所有开发均在head of develop branch上进行，每解决一个新的问题，需在head of develop branch上拉下一个新的分支，解决完毕后merge回develop branch. Head of develop branch就是我们release给系统软件的代码库。*

**Almost all development occurs at the “head” of the repository, not on branches.** This helps identify integration(集成) problems early and minimizes the amount of merging work needed. It also makes it much easier and faster to push out security fixes.

*为保证程序的正常运行（可编译、可运行），我们采用了两种措施，工程师自己进行的单元测试和功能测试、集成后的daily功能测试，daily test是自动执行的，每天自动拉下head of develop branch代码，编译运行，生成结果，工程师每天早上查看运行结果文件。*

*上述步骤仅能保证程序可正常运行，但无法判断算法的准确性，后面需要添加算法准确性测试的test case，需要考虑不同年龄、性别、人数、光线、场景、运动速度等情况。*

**Automated systems run tests frequently, often after every change to any file in the transitive dependencies(传递依赖) of the test, although this is not always feasible(可行的).** These systems automatically notify the author and reviewers of any change for which the tests failed, typically within a few minutes. Most teams make the current status of their build very conspicuous(显眼的) by installing prominent(突出的) displays or even sculptures(雕塑) with color-coded lights (green for building successfully and all tests passing, red for some tests failing, black for broken build). This helps to focus engineers’ attention on keeping the build green. Most larger teams also have a “build cop” who is responsible for ensuring that the tests continue to pass at head, by working with the authors of the offending(惹麻烦的) changes to quickly fix any problems or to roll back the offending change. (The build cop role is typically rotated among the team or among its more experienced members.) This focus on keeping the build green makes development at head practical, even for very large teams.

*这个没啥，每个gitlab工程需要设置权限，owner or developer or viewer，不能让别人瞎逼改，对吧。*

**Code ownership.** Each subtree of the repository can have a file listing the user ids of the “owners” of that subtree. Subdirectories also inherit owners from their parent directories, although that can be optionally suppressed(抑制). The owners of each subtree control write access to that subtree, as described in the code review section below. Each subtree is required to have at least two owners, although typically there are more, especially in geographically distributed teams. It is common for the whole team to be listed in the owners file. Changes to a subtree can be made by anyone at Google, not just the owners, but must be approved by an owner. This ensures that every change is reviewed by an engineer who understands the software being modified.

## The Build System

*编译工具，之前好像用Blaze编译过tensorflow，我们现在用MakeFile，没啥，其实是一样的，完成相同的功能。*

Google uses a distributed build system known as Blaze, which is responsible for compiling and linking software and for running tests. It provides standard commands for building and testing software that work across the whole repository. These standard commands and the highly optimized implementation mean that it is typically very simple and quick for any Google engineer to build and test any software in the repository. This consistency is a key enabler which helps to make it practical for engineers to make changes across project boundaries.

Programmers write “BUILD” files that Blaze uses to determine how to build their software. Build entities such as libraries, programs, and tests are declared using fairly high-level declarative build specifications that specify, for each entity, its name, its source files, and the libraries or other build entities that it depends on. These build specifications are comprised(构成) of declarations called “build rules” that each specify high-level concepts like “here is a C++ library with these source files which depends on these other libraries”, and it is up to the build system to map each build rule to a set of build steps, e.g. steps for compiling each source file and steps for linking, and for determining which compiler and compilation flags to use.

In some cases, notably Go programs, build files can be generated (and updated) automatically, since the dependency information in the BUILD files is (often) an abstraction of the dependency information in the source files. But they are nevertheless(仍然) checked in to the repository. This ensures that the build system can quickly determine dependencies by analyzing only the build files rather than the source files, and it avoids excessive coupling between the build system and compilers or analysis tools for the many different programming languages supported.

*就我们这点小工程，不需要大型的计算机集群，一台服务器跑跑就足够了。其实思想是一致的，一台服务器运行不过来，耗时太长，就上服务器集群嘛。CPU完成不了的训练，就上GPU嘛，一个GPU不行，那多装几个，没啥。*

The build system’s implementation uses Google’s distributed computing infrastructure. **The work of each build is typically distributed across hundreds or even thousands of machines.** This makes it possible to build extremely large programs quickly or to run thousands of tests in parallel.

**Individual build steps must be “hermetic(不受外界影响的)”: they depend only on their declared inputs.** Enforcing that all dependencies be correctly declared is a consequence of distributing the build: only the declared inputs are sent to the machine on which the build step is run. As a result the build system can be relied on to know the true dependencies. Even the compilers that the build system invokes are treated as inputs.

*每一个编译步骤都是确定性的，只要有相同的输入，得到的lib和可执行文件就是相同的。其实就是，编译过程要有一致性，不能相同的程序，得到不一样的编译结果，运行出来是不一样的。上述明确声明每个编译步骤的依赖关系，也是为了这个目的。*

**Individual build steps are deterministic(确定性的).** As a consequence, the build system can cache build results. Software engineers can sync their workspace back to an old change number and can rebuild and will get exactly the same binary. Furthermore, this cache can be safely shared between different users. (To make this work properly, we had to eliminate non-determinism in the tools invoked by the build, for example by scrubbing out(清除) timestamps in the generated output files.)

**The build system is reliable.** The build system tracks dependencies on changes to the build rules themselves, and knows to rebuild targets if the action to produce them changed, even if the inputs to that action didn’t, for example when only the compiler options changed. It also deals properly with interrupting the build part way, or modifying source files during the build: in such cases, you need only rerun the build command. There is never any need to run the equivalent of “make clean”.

**Build results are cached “in the cloud”.** This includes intermediate results. If another build request needs the same results, the build system will automatically reuse them rather than rebuilding, even if the request comes from a different user.

**Incremental(增量) rebuilds are fast.** The build system stays resident in memory so that for rebuilds it can incrementally analyze just the files that have changed since the last build.

*Code review或者代码提交之前，自动做一定的测试，用来测试代码的正确性，给code reviewer和开发人员一定的提示。这个其实是有必要的，最起码code review之前，运行一定的代码测试，是非常有必要的。因为我们的code review是缺失的，这一步我们当然也没有做。如果我们后面添加了code review的步骤，一定会要求开发人员，在review之前，拿出相关代码的测试结果。*

**Presubmit checks.** Google has tools for automatically running a suite of tests when initiating a code review and/or preparing to commit a change to the repository. Each subtree of the repository can contain a configuration file which determines which tests to run, and whether to run them at code review time, or immediately before submitting, or both. The tests can be either synchronous, i.e. run before sending the change for review and/or before committing the change to the repository (good for fast-running tests); or asynchronous(异步), with the results emailed to the review discussion thread. The review thread is the email thread on which the code review takes place; all the information in that thread is also displayed in the web-based code review tool.

## Code Review

*非常牛逼的code review工具，帮助reviewers更好的进行code review，发现问题并解决问题。没啥，就是个code review工具而已，相信开源的也可以满足我们的需求。*

**Google has built excellent web-based code review tools, integrated with email, that allow authors to request a review, and allows reviewers to view side-by-side diffs (with nice color coding) and comment on them.** When the author of a change initiates a code review, the reviewers are notified by e-mail, with a link to the web review tool’s page for that change. Email notifications are sent when reviewers submit their review comments. In addition, automated tools can send notifications, containing for example the results of automated tests or the findings of static analysis tools.

*每一个改动，必须有别的工程师进行code review，以保证不会出错。如果文件的修改者不是文件的owner，则必须由owner进行review或者批准当前修改，没啥，这是必须的，不能由着两个不熟悉的工程师瞎逼改。*

**All changes to the main source code repository MUST be reviewed by at least one other engineer.** In addition, if the author of a change is not one of the owners of the files being modified, then at least one of the owners must review and approve the change.

*当一个bug已经影响到上线了，非常着急，必须被快速修改，不然用户将远离我们而去，那可以运行临时上传，而不经过code review，那code review是不是可以躲过去了，白日做梦，后面还需要补上撒，要不然，劳资一直给你发消息，直到你做完了code review，腻害不腻害？*

In exceptional cases, an owner of a subtree can check in (commit) an urgent change to that subtree before it is reviewed, but a reviewer must still be named, and the change author and reviewer will get automatically nagged(唠叨) about it until the change has been reviewed and approved. In such cases, any modifications needed to address review comments must be done in a separate change, since the original change will have already been committed.

*google的工具可以自动推荐code reviewer，依据文件的修改者和拥有者、最近谁做reveiwer了，还有每个人待review的数目，不能把人累死，对吧。但是呢，每个修改者也可以自己选合适的review的人。我们在实际执行的时候，是两两之间相互做code review，不需要工具帮忙指定。*

Google has tools for automatically suggesting reviewer(s) for a given change, by looking at the ownership and authorship of the code being modified, the history of recent reviewers, and the number of pending(有待) code reviews for each potential reviewer. At least one of the owners of each subtree which a change affects must review and approve that change. But apart from that, the author is free to choose reviewer(s) as they see fit.

*由谁对自己修改的代码进行review，其实由修改者自己控制，如果觉着代码修改比较复杂，需要更多的人或更富有经验的人来做code review，那就自己找。如果代码修改相对简单，找个不那么牛逼的人即可，但是不能不做code review。*

One potential issue with code review is that if the reviewers are too slow to respond or are overly reluctant(厌恶) to approve changes, this could potentially slow down development. The fact that the code author chooses their reviewers helps avoid such problems, allowing engineers to avoid reviewers that might be overly possessive(占有的) about their code, or to send reviews for simple changes to less thorough reviewers and to send reviews for more complex changes to more experienced reviewers or to several reviewers.

*当发现一个bug之后，需要追踪到最开始引入这个bug的提交，让修改者和code reviewer都知道这个错误，找到引入这个错误的原因，打怪升级，避免以后再发生相同的问题。*

**Code review discussions for each project are automatically copied to a mailing list designated by the project maintainers.** Anyone is free to comment on any change, regardless of whether they were named as a reviewer of that change, both before and after the change is committed. If a bug is discovered, it’s common to track down the change that introduced it and to comment on the original code review thread to point out the mistake so that the original author and reviewers are aware of it.

It is also possible to send code reviews to several reviewers and then to commit the change as soon as one of them has approved (provided(倘若) either the author or the first responding reviewer is an owner, of course), before the other reviewers have commented, with any subsequent review comments being dealt with in follow-up changes. This can reduce the turnaround time for reviews.

*每个工程都有实验的部分，之前在riseauto的时候，是建立一个文件夹来保存实验性质的代码，这些代码是不用做code review的，但是推荐做。先在实验性的代码分支写代码，然后在转到主分支，做code review，这种方式是不推荐的，code review在开发过程中做更方便一些，也更容易发现问题。*

**In addition to the main section of the repository, there is an “experimental” section of the repository where the normal code review requirements are not enforced.** However, code running in production must be in the main section of the repository, and engineers are very strongly encouraged to develop code in the main section of the repository, rather than developing in experimental and then moving it to the main section, since code review is most effective when done as the code is developed rather than afterwards. In practice engineers often request code reviews even for code in experimental.

*这个很容易想到，每次修改不能太大，你一年写的代码，好做review吗？肯定不行啊！google的做法是值得学习的，即便是犯了错误，或者做了不好的事情，也没必要苦大仇深的，好像死了爹一样，开心的对待，找一个非常有乐趣的方式，人生苦短，及时行乐嘛。*

**Engineers are encouraged to keep each individual change small, with larger changes preferably broken into a series of smaller changes that a reviewer can easily review in one go.** This also makes it easier for the author to respond to major changes suggested during the review of each piece; very large changes are often too rigid(僵化) and resist reviewer-suggested changes. One way in which keeping changes small is encouraged is that the code review tools label each code review with a description of the size of the change, with changes of 30-99 lines added/deleted/removed being labelled “medium-size” and with changes of above 300 lines being labelled with increasingly disparaging(蔑视) labels, e.g. “large” (300-999), “freakin huge” (1000-1999), etc. (However, in a typically Googly way, this is kept fun by replacing these familiar descriptions with amusing alternatives on a few days each year, such as talk-like-a-pirate day.)

## Testing

*单元测试在google非常推荐和流行，没啥，我们写的每一段代码，也需要经过单元测试，但是，有意思的问题来了，啥叫单元测试？在code review之前，reviewer要求每一个新增的代码模块，都需要经过单元测试，并且给出测试结果。*

**Unit Testing is strongly encouraged and widely practiced at Google.** All code used in production is expected to have unit tests, and the code review tool will highlight if source files are added without corresponding tests. Code reviewers usually require that any change which adds new functionality should also add new tests to cover the new functionality. Mocking frameworks (which allow construction of lightweight unit tests even for code with dependencies on heavyweight libraries) are quite popular.

*集成测试和回归测试。*

Integration testing and regression testing are also widely practiced.

As discussed in "Presubmit Checks" above, testing can be automatically enforced as part of the code review and commit process.

Google also has automated tools for measuring test coverage. The results are also integrated as an optional layer in the source code browser.

*负载测试，主要是测试每个API的并发性，如果有10亿个人同时请求，会发生什么，延迟是多少，跟我们没关系，跟智美他们有关系，云端的嘛。*

**Load testing(负载测试) prior to deployment is also de rigueur at Google.** Teams are expected to produce a table or graph showing how key metrics, particularly latency and error rate, vary with the rate of incoming requests.

## Bug tracking

*每个发现的bug，都需要有个地方来追踪，测试人员可以新建bug，让研发人员来修改，我们用的是jira，梅姐都知道bug追踪，只有春爷不知道而已，哈哈。产品提的新需求，也是在jira上跟踪，只要有个地方方便记录，别忘了就行，不管啥工具。*

Google uses a bug tracking system called Buganizer for tracking issues: bugs, feature requests, customer issues, and processes (such as releases or clean-up efforts). Bugs are categorized into hierarchical components and each component can have a default assignee and default email list to CC. When sending a source change for review, engineers are prompted to associate the change with a particular issue number.

*这叫啥，过bug，只不过，我们公司的过bug跟玩儿一样，一群傻逼来过bug，过你麻痹过！过bug的时候，需要确定以下几件事，这个问题属于谁，大概是由什么原因导致的，什么时候可以解决。*

It is common (though not universal) for teams at Google to regularly scan through open issues in their component(s), prioritizing them and where appropriate assigning them to particular engineers. Some teams have a particular individual responsible for bug triage(分流), others do bug triage in their regular team meetings. Many teams at Google make use of labels on bugs to indicate whether bugs have been triaged, and which release(s) each bug is targeted to be fixed in.

## Programming languages

*我们平时的编程语言是C++和python，训练模型用python写程序，写release给系统软件的lib库时，使用C++。*

**Software engineers at Google are strongly encouraged to program in one of five officially-approved programming languages at Google: C++, Java, Python, Go, or JavaScript.** Minimizing the number of different programming languages used reduces obstacles to code reuse and programmer collaboration.

*整个视觉算法部门有统一的C++代码规范，但是没有统一python的代码规范，这个是需要做的。代码的可读性训练，这个也是我们没有做的，需要有个经验丰富的人，来训练新的小伙伴，关于代码的可读性，你写出来的代码，必须自己和别人能够读懂，不只是计算机能够读懂。release出去的代码，必须经过通过代码可读性训练的小伙伴的批准，保证代码的可读性是比较好的。*

**There are also Google style guides for each language, to ensure that code all across the company is written with similar style, layout, naming conventions(惯例), etc. In addition there is a company-wide readability training process, whereby experienced engineers who care about code readability train other engineers in how to write readable, idiomatic(惯用的) code in a particular language, by reviewing a substantial change or series of changes until the reviewer is satisfied that the author knows how to write readable code in that language.** Each change that adds non-trivial(不平凡的) new code in a particular language must be approved by someone who has passed this “readability” training process in that language.

**In addition to these five languages, many specialized domain-specific languages are used for particular purposes (e.g. the build language used for specifying build targets and their dependencies).**

*不同编程语言之间的交互，google肯定会涉及这个问题，他们公司比较大，业务比较多样，有很多业务功能的代码重用性问题。我们的业务比较单一，不会涉及代码交互问题。看着protocal buffer这么眼熟，好像tensorflow的模型存储，就是用的这个东东。还是需要看一下protocal buffer这个东东，学习一下google的牛逼工具。*

*RPC是啥东西？*

**Interoperation between these different programming languages is done mainly using Protocol Buffers.** Protocol Buffers is a way of encoding structured data in an efficient yet extensible way. It includes a domain-specific language for specifying structured data, together with a compiler that takes in such descriptions and generates code in C++, Java, Python, for constructing, accessing, serializing, and deserializing these objects. Google’s version of Protocol Buffers is integrated with Google’s RPC libraries, enabling simple cross-language RPCs, with serialization and deserialization of requests and responses handled automatically by the RPC framework.

*虽然使用的编程语言不通，但整个工程的开发过程是相同的，中间涉及到的各种流程、命令行代码等，都是相同的。开发人员只用学习一套开发流程，在这个过程中只用更换编程语言，中间的很多东西都不用重新开始学习，节省了很多学习的时间，并且可以尽量减少错误的发生。*

**Commonality of process is a key to making development easy even with an enormous code base and a diversity of languages: there is a single set of commands to perform all the usual software engineering tasks (such as check out, edit, build, test, review, commit, file bug report, etc.) and the same commands can be used no matter what project or language.** Developers don’t need to learn a new development process just because the code that they are editing happens to be part of a different project or written in a different language.

## Debugging and Profiling tools

*程序的调试和分析工具，调试自然不必说，每次写程序都涉及到调试。我们在写C++程序的时候，其实是使用VS进行调试的，在windows上进行。python不用说了，pycharm或者vs code都可以，顺便说一句，vs code真的挺好用的，微软还是很牛逼的。分析工具嘛，之前用过vtunes，分析过代码的耗时，其他的没用过。我们的程序在运行的时候，也会报出错误，使用的是google的glog，自己打印log，用于快速找到问题出在哪里，进而方便修改。在程序运行的时候，有debugging工具，如果程序出错，知道出错在什么地方，方便修改。*

*计算机堆栈之间的区别和两者的作用是什么？*

Google servers are linked with libraries that provide a number of tools for debugging running servers. In case of a server crash, a signal handler will automatically dump a stack trace to a log file, as well as saving the core file. If the crash was due to running out of heap memory, the server will dump stack traces of the allocation sites of a sampled subset of the live heap objects. There are also web interfaces for debugging that allow examining incoming and outgoing RPCs (including timing, error rates, rate limiting, etc.), changing command-line flag values (e.g. to increase logging verbosity(详细程度) for a particular module), resource consumption, profiling, and more. These tools greatly increase the overall ease of debugging to the point where it is rare to fire up a traditional debugger such as gdb.

## Release engineering

*谁来决定，你的代码库可以发布出来，给别人用？我们没有这方面的专业的人，就是自己测一下，外出测一下，没问题的话，就发布了，很草率，哈哈。我们做软件发布的时候，是由霍磊来做的，霍磊也是算法工程师。*

A few teams have dedicated release engineers, but for most teams at Google, the release engineering work is done by regular software engineers.

*有哪些库发布的工作可以自动化来完成呢？用于解放霍磊。我们是怎么发版的呢？我们不会设置固定的发版时间，遇到紧急的问题，会及时发版，当然，我们的发版依赖于系统软件的发版速度，我们一般是解决了很多问题之后，觉着可以给用户提供更好的功能了，才发版。比如，我们解决了暗光下的人脸检测和跟踪问题，我们就发版，还有口罩遮挡下的人脸检测和跟踪问题。很多问题都是模型相关的，我们也不能出现一个问题就解决，而是积累的一定程度，一起来解决。*

**Releases are done frequently for most software; weekly or fortnightly(隔周的) releases are a common goal, and some teams even release daily. This is made possible by automating most of the normal release engineering tasks.** Releasing frequently helps to keep engineers motivated (it’s harder to get excited about something if it won’t be released until many months or even years into the future) and increases overall velocity(速度) by allowing more iterations, and thus more opportunities for feedback and more chances to respond to feedback, in a given time.

*我们的工程就有一个release分支，开发在develop分支，release分支用于发布版本。*

A release typically starts in a fresh workspace, by syncing to the change number of the latest “green” build (i.e. the last change for which all the automatic tests passed), and making a release branch. The release engineer can select additional changes to be “cherry-picked”, i.e. merged from the main branch onto the release branch. Then the software will be rebuilt from scratch and the tests are run. If any tests fail, additional changes are made to fix the failures and those additional changes are cherry-picked onto the release branch, after which the software will be rebuilt and the tests rerun. When the tests all pass, the built executable(s) and data file(s) are packaged up. All of these steps are automated so that the release engineer need only run some simple commands, or even just select some entries on a menu-driven UI, and choose which changes (if any) to cherry pick.

*当一个软件被发布之后，这些东西不能直接给用户用啊，先在公司内部测试一下，这个我们是有的，先给测试团队用一下，看有没有什么问题，虽然我们的测试团队是一群傻逼。*

**Once a candidate build has been packaged up, it is typically loaded onto a “s taging” server for further integration testing by small set of users (sometimes just the development team).**

*对于服务器来说，把一部分用户的请求发送给待测试的库，看服务器有什么反馈，提前找到问题所在。新的库的结果被丢弃，还是发送给用户之前的库的结果，这个很容易想明白，至少能够符合用户的预期，不会突然引起用户的不适应。*

A useful technique involves sending a copy of (a subset of) the requests from production traffic to the staging server, but also sending those same requests to the current production servers for actual processing. The responses from the staging server are discarded, and the responses from the live production servers are sent back to the users. This helps ensure that any issues that might cause serious problems (e.g. server crashes) can be detected before putting the server into production.

*先让一小部分用户使用起来，其实我们也是符合的，不是所有的用户都会升级固件的最新版本，如果发现了问题，我们也可以及时修改。*

**The next step is to usually roll out to one or more “canary” servers that are processing a subset of the live production traffic.** Unlike the “staging” servers, these are processing and responding to real users.

Finally the release can be rolled out to all servers in all data centers. **For very high-traffic, high-reliability services, this is done with a gradual roll-out over a period of a couple of days, to help reduce the impact of any outages due to newly introduced bugs not caught by any of the previous steps.**

## Launch approval

*看起来像是之前公司组建的质量委员会的东西，我觉着太形式主义，没啥必要，质量委员会真正要站在用户的立场上，站在为产品负责的立场上，有自己的职业规范的考虑问题。如果换我的话，我会怎么做呢？让产品、硬件、测试作为质量委员会成员，不直接听命于CEO，用来审批产品是否可以上线或者上市。*

*我们的这个质量委员会是小打小闹，只考虑到产品的质量问题，没有考虑到法律条款、政策、认证、知识产权、安全性、用户隐私、可靠性等很多问题。*

The launch of any user-visible change or significant design change requires approvals from a number of people outside of the core engineering team that implements the change. In particular approvals (often subject to detailed review) are required to ensure that code complies with legal requirements, privacy requirements, security requirements, reliability requirements (e.g. having appropriate automatic monitoring to detect server outages and automatically notify the appropriate engineers), business requirements, and so forth.

The launch process is also designed to ensure that appropriate people within the company are notified whenever any significant new product or feature launches.

*google产品这么多，肯定要开发一个工具呀，我们只有一两款产品，并且集中在智能硬件，我们至少有一个文档，来做这种事情吧。*

**Google has an internal launch approval tool that is used to track the required reviews and approvals and ensure compliance with the defined launch processes for each product.** This tool is easily customizable(可定制的), so that different products or product areas can have different sets of required reviews and approvals.

## Post-mortems

*如果出现了问题，一定要写一个事后的分析报告，不是为了处罚谁，而是深入找到原因，避免再发生类似的问题，也为后续的小伙伴有一定的积累。之前仔细看过google的事后分析报告，写的都大同小异，反正要把心窝子掏出来，告诉别人，特么劳资错了。我们肯定是没有这个东西的，要不然也不能允许春爷搞这么久。*

Whenever there is a significant outage of any of our production systems, or similar mishap(意外), the people involved are required to write a post-mortem document. This document describes the incident, including title, summary, impact, timeline, root cause(s), what worked/what didn’t, and action items. **The focus is on the problems, and how to avoid them in future, not on the people or apportioning blame.** The impact section tries to quantify the effect of the incident, in terms of duration of outage, number of lost queries (or failed RPCs, etc.), and revenue(财政收入). The timeline section gives a timeline of the events leading up to the outage and the steps taken to diagnose(诊断) and rectify it. The what worked/what didn’t section describes the lessons learnt -- which practices helped to quickly detect and resolve the issue, what went wrong, and what concrete(具体的) actions (preferably filed as bugs assigned to specific people) can be take to reduce the likelihood and/or severity(严重性) of similar problems in future.

## Frequent rewrites

*一般过个几年，软件就要重构一次，唉，我们总共还没经过几年，没啥，我们没做这个。*

**Most software at Google gets rewritten every few years.**

This may seem incredibly costly. Indeed, it does consume a large fraction of Google’s resources. However, it also has some crucial benefits that are key to Google’s agility(敏捷) and long-term success. In a period of a few years, it is typical for the requirements for a product to change significantly, as the software environment and other technology around it change, and as changes in technology or in the marketplace affect user needs, desires, and expectations. Software that is a few years old was designed around an older set of requirements and is typically not designed in a way that is optimal for current requirements. Furthermore, it has typically accumulated a lot of complexity. Rewriting code cuts away all the unnecessary accumulated complexity that was addressing requirements which are no longer so important. In addition, rewriting code is a way of transferring knowledge and a sense of ownership to newer team members. This sense of ownership is crucial for productivity: engineers naturally put more effort into developing features and fixing problems in code that they feel is “theirs”. Frequent rewrites also encourage mobility(流动性) of engineers between different projects which helps to encourage cross-pollination(交叉授粉) of ideas. Frequent rewrites also help to ensure that code is written using modern technology and methodology.
