# Software Development

## The Source Repository

*你们的代码存储在哪里？github or gitlab?*

**Most of Google’s code is stored in a single unified source-code repository, and is accessible to all software engineers at Google.** (Customer data is tightly secured, it's only source code that's accessible.) There are some notable exceptions to the use of this single widely accessible repository, particularly the two large open-source projects Chrome and Android, which use separate open-source repositories, and some high-value or security-critical pieces of code for which read access is locked down more tightly. But most Google projects share the same repository. As of January 2015, this 86 terabyte repository contained a billion files, including over 9 million source code files containing a total of 2 billion lines of source code, with a history of 35 million commits and a change rate of 40 thousand commits per work day. Write access to the repository is controlled: only the listed owners of each subtree of the repository can approve changes to that subtree. But generally any engineer can access any piece of code, can check it out and build it, can make local modifications, can test them, and can send changes for review by the code owners, and if an owner approves, can check in (commit) those changes. Culturally, engineers are encouraged to fix anything that they see is broken and know how to fix, regardless of project boundaries. This empowers engineers and leads to higher-quality infrastructure(基础架构) that better meets the needs of those using it.

*我们的开发习惯与google相同，所有开发均在head of develop branch上进行，每解决一个新的问题，需在head of develop branch上拉下一个新的分支，解决完毕后merge回develop branch. Head of develop branch就是我们release给系统软件的代码库。*

**Almost all development occurs at the “head” of the repository, not on branches.** This helps identify integration(集成) problems early and minimizes the amount of merging work needed. It also makes it much easier and faster to push out security fixes.

*为保证程序的正常运行（可编译、可运行），我们采用了两种措施，工程师自己进行的单元测试和功能测试、集成后的daily功能测试，daily test是自动执行的，每天自动拉下head of develop branch代码，编译运行，生成结果，工程师每天早上查看运行结果文件。*

*上述步骤仅能保证程序可正常运行，但无法判断算法的准确性，后面需要添加算法准确性测试的test case，需要考虑不同年龄、性别、人数、光线、场景、运动速度等情况。*

**Automated systems run tests frequently, often after every change to any file in the transitive dependencies(传递依赖) of the test, although this is not always feasible(可行的).** These systems automatically notify the author and reviewers of any change for which the tests failed, typically within a few minutes. Most teams make the current status of their build very conspicuous(显眼的) by installing prominent(突出的) displays or even sculptures(雕塑) with color-coded lights (green for building successfully and all tests passing, red for some tests failing, black for broken build). This helps to focus engineers’ attention on keeping the build green. Most larger teams also have a “build cop” who is responsible for ensuring that the tests continue to pass at head, by working with the authors of the offending(惹麻烦的) changes to quickly fix any problems or to roll back the offending change. (The build cop role is typically rotated among the team or among its more experienced members.) This focus on keeping the build green makes development at head practical, even for very large teams.

*这个没啥，每个gitlab工程需要设置权限，owner or developer or viewer，不能让别人瞎逼改，对吧。*

**Code ownership.** Each subtree of the repository can have a file listing the user ids of the “owners” of that subtree. Subdirectories also inherit owners from their parent directories, although that can be optionally suppressed(抑制). The owners of each subtree control write access to that subtree, as described in the code review section below. Each subtree is required to have at least two owners, although typically there are more, especially in geographically distributed teams. It is common for the whole team to be listed in the owners file. Changes to a subtree can be made by anyone at Google, not just the owners, but must be approved by an owner. This ensures that every change is reviewed by an engineer who understands the software being modified.

## The Build System

*编译工具，之前好像用Blaze编译过tensorflow，我们现在用MakeFile，没啥，其实是一样的，完成相同的功能。*

Google uses a distributed build system known as Blaze, which is responsible for compiling and linking software and for running tests. It provides standard commands for building and testing software that work across the whole repository. These standard commands and the highly optimized implementation mean that it is typically very simple and quick for any Google engineer to build and test any software in the repository. This consistency is a key enabler which helps to make it practical for engineers to make changes across project boundaries.

Programmers write “BUILD” files that Blaze uses to determine how to build their software. Build entities such as libraries, programs, and tests are declared using fairly high-level declarative build specifications that specify, for each entity, its name, its source files, and the libraries or other build entities that it depends on. These build specifications are comprised(构成) of declarations called “build rules” that each specify high-level concepts like “here is a C++ library with these source files which depends on these other libraries”, and it is up to the build system to map each build rule to a set of build steps, e.g. steps for compiling each source file and steps for linking, and for determining which compiler and compilation flags to use.

In some cases, notably Go programs, build files can be generated (and updated) automatically, since the dependency information in the BUILD files is (often) an abstraction of the dependency information in the source files. But they are nevertheless(仍然) checked in to the repository. This ensures that the build system can quickly determine dependencies by analyzing only the build files rather than the source files, and it avoids excessive coupling between the build system and compilers or analysis tools for the many different programming languages supported.
